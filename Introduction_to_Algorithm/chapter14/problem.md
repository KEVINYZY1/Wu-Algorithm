# chapter14

## 思考题
###Problems 1
#### Q 最大重叠点
假设希望对一组区间记录一个最大重叠点，亦即覆盖它的区间最多的那个点。 

a)证明：最大重叠点总存在于某段的端点上。 

b)设计一数据结构，能有效地支持操作INTERVAL-INSERT,INTERVAL-DELETE和返回最大重叠点操作FIND-POM。  
(提示：将所有端点组织成红黑树。左端点关联+1值，而右端点关联-1值。附加一些维护最大重叠点的信息以扩张树中结点。）
 
#### A
* a. 给定n/2个区间，那么从小到大有n个端点，将这n个端点从小到大排列起来，那么最大重叠点对就的就是使p[e1] + p[e 2 ] + · · · + p[e i]这个式子取得最大值的点，这个相对来说比较好理解。 （注意 p[]对于左端点是1，对于右端点是-1）   
	如果前面的区间只出现了左端点，还没有出现右端点，那么肯定会与当前这个区间重叠。如果左右端点都出现过了，那么也就不会与当前区间重叠了，同时左端点p为+1,右端点p为-1,相加为0。有了这个式子，就非常有效的把求最大重叠点的这个问题抽象化了，转换为了如何求这个式子的最大值。
* b. 扩展红黑树   
对所有端点排序，采用分治法。  
当一个端点（设为i）把区间分成了左右两部分和端点i自身，而且知道了1,2,3,....i-1这i-1个点的最大重叠点(设为i->left->m)，以及i+1,i+2,...n这n-i个点的最大重叠点(设为i->right->m)。这个时候整个区间的最大重叠点（对应的重叠次数设为m）所处位置分成了三种情况:    
1 在i的左边  m1 = i->left->m;   
2 就是i本身  m2 = i->left->v (i左边区间的所有端点的p值之和）+ i->p;   
3 在i的右边  m3 = i->left->v (i左边区间的所有端点的p值之和）+ i->p +i->right->m;   
所以m = max（m1,m2,m3).   
故红黑树的基础结构p[x]=1表示它是区间的左端点，p[x]=-1表示它是区间的右端点  
附加信息v[x]：以x为根的所有结点的p值之和   
m[x]：MAX(SUM([left[x], i))   
o[x]：以x为根的所有结点中的最大覆盖点   

###Problems 2
#### Q Josephus排列  
Josephus问题的定义如下：假设n个人排成环形，且有以正整数m<=n。从某个制定的人开始，沿环报数，每遇到第m个人就让其出列，且报数进行下去。这个过程一直进行到所有人都出列为止。每个人出列的次序定义了整数1，2，...，n的(n, m)-Josephus排列。例如，(7,3)-Josephus排列为<3,6,2,7,5,1,4>。   
a) 假设m为常数。请描述一个O(n)时间的算法，使之对给定的整数n，输出(n, m)-Josephus排列。    
b) 假设m不是个常数。请描述一个O(nlgn)时间的算法，使给定的整数n和m，输出(n, m)-Josephus排列。

#### A
* a. m为常数，可以用循环链表，用head,tail标志头尾指针使其易于表示循环结构。循环输出后删除结点n次，每次外层循环时，内层都固定循环m次。所以运行时间为O(mn)=O(n).
* b. m为非常数。可以用顺序统计树，用size属性记录每个结点在当前树中所在的位置。经过一个取余过程，每次都能正确找到并输出删除每个结点，在经过n次循环，每次循环都要找到一个结点输出并删除它，所以每次循环都要花费O(lgn)时间。总的运行时间是O(nlgn).